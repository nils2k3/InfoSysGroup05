# service_request.py - Generated by Extractor Generator Tool
"""
ServiceRequestExtractor - Data extractor for SERVICE_REQUEST table

Generated on: 2025-12-11 14:55:10
CSV Inputs: OfferedCourses
Dependencies: SUBJECT, SEMESTER_PLANNING, DEPARTMENT

This extractor follows the DataExtractor contract for the database population system.
Modify the extract() method to implement your specific business logic.
"""

import pandas as pd
import logging
from typing import Dict, List, Any
from base_extractor import DataExtractor

logger = logging.getLogger(__name__)


class ServiceRequestExtractor(DataExtractor):
    """Extract data for SERVICE_REQUEST table"""
    
    @property
    def table_name(self) -> str:
        """Return the database table name this extractor targets"""
        return "SERVICE_REQUEST"
    
    @property
    def dependencies(self) -> List[str]:
        """Return list of table names this extractor depends on"""
        return ['SUBJECT', 'SEMESTER_PLANNING', 'DEPARTMENT']
    
    def extract(self, OfferedCourses: pd.DataFrame, subject: List[Dict[str, Any]], semester_planning: List[Dict[str, Any]], department: List[Dict[str, Any]], **kwargs) -> List[Dict[str, Any]]:
        """
        Extract data for SERVICE_REQUEST table.
        
        Args:
        CSV Data:
            OfferedCourses: DataFrame loaded from OfferedCourses.csv
        Dependencies:
            subject: List of SUBJECT table records from dependency resolution
            semester_planning: List of SEMESTER_PLANNING table records from dependency resolution
            department: List of DEPARTMENT table records from dependency resolution
        Additional:
            **kwargs: Additional parameters passed by the extraction system
        
        Returns:
            List of dictionaries representing SERVICE_REQUEST table records
        """
        if not subject or not semester_planning or not department:
            logger.warning("Missing dependencies")
            return []
        
        def normalize_text(value: Any) -> str:
            if value is None or (isinstance(value, float) and pd.isna(value)):
                return None
            text = str(value).strip()
            if not text:
                return None
            return " ".join(text.split()).lower()

        def normalize_program(value: Any) -> str:
            if value is None or (isinstance(value, float) and pd.isna(value)):
                return None
            text = str(value).strip()
            if not text:
                return None
            return text.upper()

        def normalize_semester(value: Any) -> int:
            if value is None or (isinstance(value, float) and pd.isna(value)):
                return None
            try:
                return int(float(value))
            except (ValueError, TypeError):
                return None

        def normalize_term(value: Any) -> str:
            if value is None or (isinstance(value, float) and pd.isna(value)):
                return None
            text = str(value).strip()
            if not text:
                return None
            return text.upper()

        subject_lookup = {}
        for s in subject:
            key = (
                normalize_text(s.get('S_NAME')),
                normalize_semester(s.get('S_SEMESTER')),
                normalize_program(s.get('FK_ST_NAME')),
            )
            if None in key:
                continue
            if key in subject_lookup:
                logger.warning(f"Duplicate subject key {key}, keeping first match")
                continue
            subject_lookup[key] = s['S_ID']

        semester_lookup = {}
        for s in semester_planning:
            term_key = normalize_term(s.get('SP_TERM'))
            if term_key:
                semester_lookup[term_key] = s['SP_ID']

        dept_names = {str(d['D_NAME']).strip() for d in department if d.get('D_NAME')}
        
        # Filter for service courses (srvProvider != srvClient)
        df = OfferedCourses[OfferedCourses['srvProvider'] != OfferedCourses['srvClient']].copy()
        df = df[['sbjName', 'sbjlevel', 'studyPrg', 'term', 'srvProvider', 'srvClient', 'numSchd', 'assNotes']]
        df['sbjName_norm'] = df['sbjName'].apply(normalize_text)
        df['sbjlevel_norm'] = df['sbjlevel'].apply(normalize_semester)
        df['studyPrg_norm'] = df['studyPrg'].apply(normalize_program)
        df['term_norm'] = df['term'].apply(normalize_term)
        df = df.dropna(subset=['sbjName_norm', 'sbjlevel_norm', 'studyPrg_norm', 'term_norm'])
        df = df.drop_duplicates(subset=['sbjName_norm', 'sbjlevel_norm', 'studyPrg_norm', 'term_norm',
                                        'srvProvider', 'srvClient'])
        
        records = []
        id_counter = 1
        
        missing_subject = 0
        missing_semester = 0

        for _, row in df.iterrows():
            provider = str(row['srvProvider']).strip()
            client = str(row['srvClient']).strip()

            subject_key = (row['sbjName_norm'], row['sbjlevel_norm'], row['studyPrg_norm'])
            subject_id = subject_lookup.get(subject_key)
            semester_id = semester_lookup.get(row['term_norm'])

            if subject_id is None:
                missing_subject += 1
                continue
            if semester_id is None:
                missing_semester += 1
                continue
            if provider not in dept_names or client not in dept_names:
                continue
            
            hours = pd.to_numeric(row['numSchd'], errors='coerce')
            if pd.isna(hours):
                hours = 0.0
            
            record = {
                'SR_ID': id_counter,
                'FK_S_ID': subject_id,
                'FK_REQUESTING_D_NAME': client,
                'FK_PROVIDING_D_NAME': provider,
                'SR_HOURS': float(hours),
                'SR_STATUS': 'APPROVED',
                'FK_SEMESTER': semester_id,
                "SR_NOTES": str(row['assNotes']) if not pd.isna(row['assNotes']) else None
            }
            records.append(record)
            id_counter += 1

        if missing_subject:
            logger.warning(f"{missing_subject} service requests skipped (subject not found)")
        if missing_semester:
            logger.warning(f"{missing_semester} service requests skipped (semester not found)")
        
        logger.info(f"{self.__class__.__name__} extracted {len(records)} records")
        return records
