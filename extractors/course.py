# course.py - Generated by Extractor Generator Tool
"""
CourseExtractor - Data extractor for COURSE table

Generated on: 2025-12-11 14:55:10
CSV Inputs: OfferedCourses
Dependencies: OFFERING, TEACHER, SUBJECT

This extractor follows the DataExtractor contract for the database population system.
Modify the extract() method to implement your specific business logic.
"""

import pandas as pd
from typing import Dict, List, Any
from base_extractor import DataExtractor


class CourseExtractor(DataExtractor):
    """Extract data for COURSE table"""
    
    @property
    def table_name(self) -> str:
        """Return the database table name this extractor targets"""
        return "COURSE"
    
    @property
    def dependencies(self) -> List[str]:
        """Return list of table names this extractor depends on"""
        return ['OFFERING', 'TEACHER', 'SUBJECT']
    
    def extract(self, OfferedCourses: pd.DataFrame, offering: List[Dict[str, Any]], teacher: List[Dict[str, Any]], subject: List[Dict[str, Any]], **kwargs) -> List[Dict[str, Any]]:
        """
        Extract data for COURSE table.
        
        Args:
        CSV Data:
            OfferedCourses: DataFrame loaded from OfferedCourses.csv
        Dependencies:
            offering: List of OFFERING table records from dependency resolution
            teacher: List of TEACHER table records from dependency resolution
            subject: List of SUBJECT table records from dependency resolution
        Additional:
            **kwargs: Additional parameters passed by the extraction system
        
        Returns:
            List of dictionaries representing COURSE table records
            
        TODO: Implement your extraction logic here
        Example structure:
        ```python
        records = []
        for index, row in some_dataframe.iterrows():
            record = {
                'COLUMN_1': row['source_column_1'],
                'COLUMN_2': row['source_column_2'],
                # Add more columns as needed
            }
            records.append(record)
        return records
        ```
        """

        # Get relevant columns and remove duplicates
        coursesDF = OfferedCourses[[
            'lecNo', 'sbjNo', 'assNotes', 'term', 'cntCurr', 'cntLec', 'cntSchd'
        ]].copy()
        
        # Add index as course ID
        coursesDF['course_id'] = range(1, len(coursesDF) + 1)

        # Create lookup sets for validation (same as original)
        valid_teacher_ids = {t['T_ID'] for t in teacher}
        valid_subject_nrs = {s['S_NR'] for s in subject}
        
        # Create offering lookup: (subject_id, semester) -> offering_id
        offering_lookup = {}
        for o in offering:
            key = (o.get('FK_SUBJECT'), o.get('FK_SEMESTER_PLANNING'))
            offering_lookup[key] = o.get('O_ID')
        
        def safe_numeric(value):
            """Convert numeric strings with comma decimal separator to float"""
            if pd.isna(value):
                return 0.0
            if isinstance(value, str):
                try:
                    return float(value.replace(',', '.'))
                except ValueError:
                    return 0.0
            return float(value)
        
        courses = []
        for index, row in coursesDF.iterrows():
            # Skip rows with missing required data
            if pd.isna(row['lecNo']) or pd.isna(row['sbjNo']):
                continue
            
            teacher_id = int(row['lecNo'])
            subject_nr = str(row['sbjNo'])
            term = str(row['term']) if not pd.isna(row['term']) else None
            
            # Skip if no term available
            if not term:
                continue 
            
            # Validate foreign keys (same as original logic)
            if teacher_id not in valid_teacher_ids:
                continue  # Skip courses with invalid teacher
            
            if subject_nr not in valid_subject_nrs:
                continue  # Skip courses with invalid subject
            
            # Find offering_id - we need to lookup via subject and term
            # This requires SUBJECT and SEMESTER_PLANNING to be extracted first
            # For now we use a simple approach - find first matching offering
            offering_id = None
            for o in offering:
                if o.get('FK_SUBJECT') == subject_nr:
                    offering_id = o.get('O_ID')
                    break
            
            # Skip if no offering found
            if not offering_id:
                continue
            
            course = {
                'C_ID': int(row['course_id']),  # Use generated course ID
                'C_TEACHER': teacher_id,  # Foreign key to TEACHER.T_ID
                'C_SUBJECT': subject_nr,  # Foreign key to SUBJECT.S_NR
                'C_ACTUAL_STUPO_HOURS': safe_numeric(row['cntCurr']),
                'C_ACTUAL_SCHEDULE_HOURS': safe_numeric(row['cntSchd']),
                'C_CREDITED_HOURS': safe_numeric(row['cntLec']),
                'C_TEACHER_COMMENT': str(row['assNotes']) if not pd.isna(row['assNotes']) else None,
                'C_SEMESTER': str(row['term']) if not pd.isna(row['term']) else None,
                'FK_OFFERING': offering_id  # Foreign key to OFFERING.O_ID
            }
            courses.append(course)
        
        return courses
