# professor.py - Generated by Extractor Generator Tool
"""
ProfessorExtractor - Data extractor for PROFESSOR table

Generated on: 2025-12-11 14:55:09
CSV Inputs: OfferedCourses
Dependencies: TEACHER

This extractor follows the DataExtractor contract for the database population system.
Modify the extract() method to implement your specific business logic.
"""

import pandas as pd
import logging
from typing import Dict, List, Any
from base_extractor import DataExtractor

logger = logging.getLogger(__name__)


class ProfessorExtractor(DataExtractor):
    """Extract data for PROFESSOR table"""
    
    @property
    def table_name(self) -> str:
        """Return the database table name this extractor targets"""
        return "PROFESSOR"
    
    @property
    def dependencies(self) -> List[str]:
        """Return list of table names this extractor depends on"""
        return ['TEACHER']
    
    def extract(self, OfferedCourses: pd.DataFrame, teacher: List[Dict[str, Any]], **kwargs) -> List[Dict[str, Any]]:
        """
        Extract data for PROFESSOR table by filtering TEACHER records and enriching with room data.
        
        PROFESSOR is a subtype of TEACHER. This extractor:
        1. Filters the TEACHER list to only professors (based on OfferedCourses.isprof)
        2. Looks up office room (P_ROOM) from OfferedCourses using LASTNAME (lecName) matching
        
        Args:
        CSV Data:
            OfferedCourses: DataFrame loaded from OfferedCourses.csv (for P_ROOM lookup via lecName)
        Dependencies:
            teacher: List of TEACHER table records (filtered by professor IDs)
        Additional:
            **kwargs: Additional parameters passed by the extraction system
        
        Returns:
            List of dictionaries representing PROFESSOR table records
        """
        if not teacher:
            logger.warning("TEACHER data is empty. Cannot extract PROFESSOR records.")
            return []
        
        records = []

        # 0. Build professor ID set from OfferedCourses (lecNo where isprof == 'WAHR')
        professor_ids = set()
        if OfferedCourses is not None and len(OfferedCourses) > 0:
            df_ids = OfferedCourses[['lecNo', 'isprof']].copy()
            df_ids = df_ids.dropna(subset=['lecNo'])
            prof_rows = df_ids[df_ids['isprof'] == 'WAHR']
            for _, row in prof_rows.iterrows():
                try:
                    professor_ids.add(int(row['lecNo']))
                except (TypeError, ValueError):
                    continue
        if not professor_ids:
            logger.warning("No professor IDs found in OfferedCourses (isprof == 'WAHR').")
            return []
        
        # 1. Build lookup from OfferedCourses: Last Name (lecName) -> Room (lecRoom)
        room_lookup = {}
        if OfferedCourses is not None and len(OfferedCourses) > 0:
            df_oc = OfferedCourses.copy()
            
            # Standardisiere die Spaltenwerte
            df_oc['lecName_str'] = df_oc['lecName'].astype(str).str.strip()
            df_oc['lecRoom_str'] = df_oc['lecRoom'].astype(str).str.strip()
            
            # Filter: nur Professoren mit isprof == 'WAHR'
            professors_courses = df_oc[
                (df_oc['isprof'] == 'WAHR') & 
                (df_oc['lecRoom_str'] != '') & 
                (df_oc['lecRoom_str'] != 'nan')
            ]
            
            # Erstelle das Lookup mit NACHNAMEN als Schl√ºssel (lecName = Nachname in CSV)
            for _, row in professors_courses.drop_duplicates(subset=['lecName_str']).iterrows():
                room_lookup[row['lecName_str']] = row['lecRoom_str']
        
        # 2. Filter TEACHER list: only extract professors (by ID from OfferedCourses)
        for teacher_record in teacher:
            teacher_id = teacher_record.get('T_ID')
            teacher_lastname = teacher_record.get('T_LASTNAME')
            if teacher_id not in professor_ids or not teacher_lastname:
                continue

            # Lookup mit NACHNAMEN (T_LASTNAME) in der NACHNAMEN-Map (lecName)
            room = room_lookup.get(teacher_lastname, 'N/A')

            record = {
                'P_ID': teacher_id,
                'P_ROOM': room
            }
            records.append(record)
        
        logger.info(f"{self.__class__.__name__} extracted {len(records)} professor records")
        return records
