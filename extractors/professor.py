# professor.py - Generated by Extractor Generator Tool
"""
ProfessorExtractor - Data extractor for PROFESSOR table

Generated on: 2025-12-11 14:55:09
CSV Inputs: OfferedCourses
Dependencies: TEACHER

This extractor follows the DataExtractor contract for the database population system.
Modify the extract() method to implement your specific business logic.
"""

import pandas as pd
import logging
from typing import Dict, List, Any
from base_extractor import DataExtractor

logger = logging.getLogger(__name__)


class ProfessorExtractor(DataExtractor):
    """Extract data for PROFESSOR table"""
    
    @property
    def table_name(self) -> str:
        """Return the database table name this extractor targets"""
        return "PROFESSOR"
    
    @property
    def dependencies(self) -> List[str]:
        """Return list of table names this extractor depends on"""
        return ['TEACHER']
    
    def extract(self, OfferedCourses: pd.DataFrame, teacher: List[Dict[str, Any]], **kwargs) -> List[Dict[str, Any]]:
        """
        Extract data for PROFESSOR table by filtering TEACHER records and enriching with room data.
        
        PROFESSOR is a subtype of TEACHER. This extractor:
        1. Filters the TEACHER list to only professors (T_ISPROFESSOR = True)
        2. Looks up office room (P_ROOM) from OfferedCourses using LASTNAME (lecName) matching
        
        Args:
        CSV Data:
            OfferedCourses: DataFrame loaded from OfferedCourses.csv (for P_ROOM lookup via lecName)
        Dependencies:
            teacher: List of TEACHER table records (filtered by T_ISPROFESSOR flag)
        Additional:
            **kwargs: Additional parameters passed by the extraction system
        
        Returns:
            List of dictionaries representing PROFESSOR table records
        """
        if not teacher:
            logger.warning("TEACHER data is empty. Cannot extract PROFESSOR records.")
            return []
        
        records = []
        
        # 1. Build lookup from OfferedCourses: Last Name (lecName) -> Room (lecRoom)
        room_lookup = {}
        if OfferedCourses is not None and len(OfferedCourses) > 0:
            df_oc = OfferedCourses.copy()
            
            # Standardisiere die Spaltenwerte
            df_oc['lecName_str'] = df_oc['lecName'].astype(str).str.strip()
            df_oc['lecRoom_str'] = df_oc['lecRoom'].astype(str).str.strip()
            
            # Filter: nur Professoren mit isprof == 'WAHR'
            professors_courses = df_oc[
                (df_oc['isprof'] == 'WAHR') & 
                (df_oc['lecRoom_str'] != '') & 
                (df_oc['lecRoom_str'] != 'nan')
            ]
            
            # Erstelle das Lookup mit NACHNAMEN als Schl√ºssel (lecName = Nachname in CSV)
            for _, row in professors_courses.drop_duplicates(subset=['lecName_str']).iterrows():
                room_lookup[row['lecName_str']] = row['lecRoom_str']
        
        # 2. Filter TEACHER list: only extract professors (T_ISPROFESSOR = True)
        for teacher_record in teacher:
            if teacher_record.get('T_ISPROFESSOR') == True and teacher_record.get('T_LASTNAME'):
                teacher_id = teacher_record.get('T_ID')
                teacher_lastname = teacher_record.get('T_LASTNAME')
                
                # Lookup mit NACHNAMEN (T_LASTNAME) in der NACHNAMEN-Map (lecName)
                room = room_lookup.get(teacher_lastname, 'N/A')
                
                record = {
                    'P_ID': teacher_id,
                    'P_ROOM': room
                }
                records.append(record)
        
        logger.info(f"{self.__class__.__name__} extracted {len(records)} professor records")
        return records
