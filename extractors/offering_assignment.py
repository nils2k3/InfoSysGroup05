# offering_assignment.py - Generated by Extractor Generator Tool
"""
OfferingAssignmentExtractor - Data extractor for OFFERING_ASSIGNMENT table

Generated on: 2025-12-11 14:55:10
CSV Inputs: OfferedCourses
Dependencies: OFFERING, TEACHER

This extractor follows the DataExtractor contract for the database population system.
Modify the extract() method to implement your specific business logic.
"""

import pandas as pd
import logging
from typing import Dict, List, Any
from base_extractor import DataExtractor

logger = logging.getLogger(__name__)


class OfferingAssignmentExtractor(DataExtractor):
    """Extract data for OFFERING_ASSIGNMENT table"""
    
    @property
    def table_name(self) -> str:
        """Return the database table name this extractor targets"""
        return "OFFERING_ASSIGNMENT"
    
    @property
    def dependencies(self) -> List[str]:
        """Return list of table names this extractor depends on"""
        return ['OFFERING', 'TEACHER']
    
    def extract(self, OfferedCourses: pd.DataFrame, offering: List[Dict[str, Any]], teacher: List[Dict[str, Any]], **kwargs) -> List[Dict[str, Any]]:
        """
        Extract data for OFFERING_ASSIGNMENT table.
        
        Args:
        CSV Data:
            OfferedCourses: DataFrame loaded from OfferedCourses.csv
        Dependencies:
            offering: List of OFFERING table records from dependency resolution
            teacher: List of TEACHER table records from dependency resolution
        Additional:
            **kwargs: Additional parameters passed by the extraction system
        
        Returns:
            List of dictionaries representing OFFERING_ASSIGNMENT table records
        """
        if not offering or not teacher:
            logger.warning("Missing dependencies")
            return []
        
        # Create offering lookup by subject+term
        offering_by_subj_term = {}
        for o in offering:
            key = (o['FK_SUBJECT'], o['FK_SEMESTER_PLANNING'])
            offering_by_subj_term[key] = o
        
        # Create semester lookup
        semester_terms = {}
        if 'semester_planning' in kwargs:
            for s in kwargs['semester_planning']:
                semester_terms[s['SP_ID']] = s['SP_TERM']
        
        teacher_ids = {t['T_ID'] for t in teacher}
        
        df = OfferedCourses[['lecNo', 'sbjNo', 'term', 'cntLec']].copy()
        df = df.dropna(subset=['lecNo', 'sbjNo', 'term'])
        df = df[df['lecNo'] != 0]
        
        records = []
        id_counter = 1
        
        for _, row in df.iterrows():
            teacher_id = int(row['lecNo'])
            if teacher_id not in teacher_ids:
                continue
            
            # Find matching offering
            offering_rec = None
            for o in offering:
                if o['FK_SUBJECT'] == str(row['sbjNo']):
                    offering_rec = o
                    break
            
            if not offering_rec:
                continue
            
            hours = pd.to_numeric(row['cntLec'], errors='coerce')
            if pd.isna(hours):
                hours = 0.0
            
            record = {
                'OA_ID': id_counter,
                'FK_OFFERING': offering_rec['O_ID'],
                'FK_TEACHER': teacher_id,
                'OA_ROLE': None,
                'OA_ASSIGNED_HOURS': float(hours)
            }
            records.append(record)
            id_counter += 1
        
        logger.info(f"{self.__class__.__name__} extracted {len(records)} records")
        return records
