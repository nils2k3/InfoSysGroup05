#!/usr/bin/env python3
"""
Extractor Generator Tool

A robust code generation tool for creating database table extractors.
Implements Template-Based Generation with Builder Pattern and comprehensive validation.

Architecture:
- ExtractorTemplate: Manages code templates (Strategy Pattern)
- ExtractorBuilder: Constructs extractor definitions (Builder Pattern)
- ExtractorGenerator: Coordinates generation process (Facade Pattern)
- CLI: User interface with validation (Command Pattern)
"""

import os
import re
import sys
import argparse
import tempfile
import shutil
from pathlib import Path
from typing import List, Dict, Optional, Set
from dataclasses import dataclass
from datetime import datetime
import logging

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

@dataclass
class ExtractorDefinition:
    """Immutable data class representing an extractor specification"""
    table_name: str
    class_name: str
    file_name: str
    csv_inputs: List[str]
    dependencies: List[str]
    
    def __post_init__(self):
        """Validate the extractor definition after construction"""
        if not self.table_name:
            raise ValueError("Table name cannot be empty")
        if not self.class_name:
            raise ValueError("Class name cannot be empty")
        if not self.file_name:
            raise ValueError("File name cannot be empty")

class ExtractorTemplate:
    """
    Template engine for generating extractor code.
    Implements Strategy Pattern for different template types.
    """
    
    @staticmethod
    def get_base_template() -> str:
        """Return the base extractor template with placeholders"""
        return '''# {file_name} - Generated by Extractor Generator Tool
"""
{class_name} - Data extractor for {table_name} table

Generated on: {timestamp}
CSV Inputs: {csv_inputs}
Dependencies: {dependencies}

This extractor follows the DataExtractor contract for the database population system.
Modify the extract() method to implement your specific business logic.
"""

import pandas as pd
from typing import Dict, List, Any
from base_extractor import DataExtractor


class {class_name}(DataExtractor):
    """Extract data for {table_name} table"""
    
    @property
    def table_name(self) -> str:
        """Return the database table name this extractor targets"""
        return "{table_name}"
    
    @property
    def dependencies(self) -> List[str]:
        """Return list of table names this extractor depends on"""
        return {dependencies_list}
    
    def extract(self, {extract_parameters}) -> List[Dict[str, Any]]:
        """
        Extract data for {table_name} table.
        
        Args:{parameter_docs}
        
        Returns:
            List of dictionaries representing {table_name} table records
            
        TODO: Implement your extraction logic here
        Example structure:
        ```python
        records = []
        for index, row in some_dataframe.iterrows():
            record = {{
                'COLUMN_1': row['source_column_1'],
                'COLUMN_2': row['source_column_2'],
                # Add more columns as needed
            }}
            records.append(record)
        return records
        ```
        """
        # TODO: Replace this placeholder with your extraction logic
        logger.warning(f"{{self.__class__.__name__}} is using placeholder implementation")
        logger.info(f"Available parameters: {{list(kwargs.keys()) if 'kwargs' in locals() else 'None'}}")
        
        # Placeholder implementation - replace with actual logic
        records = []
        
        # Example: If you have a DataFrame parameter, process it
        {extraction_example}
        
        logger.info(f"{{self.__class__.__name__}} extracted {{len(records)}} records")
        return records
'''
    
    @staticmethod
    def generate_extraction_example(csv_inputs: List[str], dependencies: List[str]) -> str:
        """Generate example extraction code based on CSV inputs and dependencies"""
        examples = []
        
        # CSV processing example
        if csv_inputs:
            primary_csv = csv_inputs[0]
            examples.append(f'''# Example using primary CSV: {primary_csv}
        if '{primary_csv}' in locals():
            df = {primary_csv}
            for index, row in df.iterrows():
                # TODO: Replace with actual column mappings
                record = {{
                    'ID': row.get('id', index),  # Replace 'id' with actual column
                    'NAME': row.get('name', f'Record_{{index}}'),  # Replace with actual column
                    # Add more columns based on your table schema
                }}
                records.append(record)''')
        
        # Dependency usage example
        if dependencies:
            dep_name = dependencies[0].lower()
            table_name = dependencies[0]
            # Fix: Properly escape braces and use string concatenation for complex template
            lookup_example = f"{dep_name}_lookup = {{record['ID']: record for record in {dep_name}}}"
            examples.append(f'''
        
        # Example using dependency data: {table_name}
        if {dep_name}:
            # Access dependency records for foreign key lookups
            {lookup_example}
            
            # Example: Use dependency data in extraction logic
            for index, row in some_dataframe.iterrows():
                dependency_id = row.get('dependency_id')  # Replace with actual FK column
                if dependency_id in {dep_name}_lookup:
                    # Use dependency record data
                    dep_record = {dep_name}_lookup[dependency_id]
                    # TODO: Implement logic using dependency data
                    pass''')
        
        if not examples:
            examples.append('''# No CSV inputs or dependencies specified
        # You'll need to implement extraction logic based on provided parameters''')
        
        return "\n".join(examples)
    
    @staticmethod
    def generate_extract_parameters(csv_inputs: List[str], dependencies: List[str]) -> str:
        """Generate method parameters based on CSV inputs and dependencies"""
        params = []
        
        # CSV inputs as DataFrames
        if csv_inputs:
            params.extend([f"{csv}: pd.DataFrame" for csv in csv_inputs])
        
        # Dependencies as extracted data (List of dictionaries)
        if dependencies:
            dep_params = [f"{dep.lower()}: List[Dict[str, Any]]" for dep in dependencies]
            params.extend(dep_params)
        
        # Always include **kwargs for additional parameters
        params.append("**kwargs")
        
        return ", ".join(params) if params != ["**kwargs"] else "**kwargs"
    
    @staticmethod
    def generate_parameter_docs(csv_inputs: List[str], dependencies: List[str]) -> str:
        """Generate parameter documentation for CSV inputs and dependencies"""
        if not csv_inputs and not dependencies:
            return "\n            **kwargs: Additional parameters passed by the extraction system"
        
        docs = []
        
        # Document CSV inputs
        if csv_inputs:
            docs.append("        CSV Data:")
            for csv in csv_inputs:
                docs.append(f"            {csv}: DataFrame loaded from {csv}.csv")
        
        # Document dependencies 
        if dependencies:
            docs.append("        Dependencies:")
            for dep in dependencies:
                param_name = dep.lower()
                docs.append(f"            {param_name}: List of {dep} table records from dependency resolution")
        
        # Always document kwargs
        docs.append("        Additional:")
        docs.append("            **kwargs: Additional parameters passed by the extraction system")
        
        return "\n" + "\n".join(docs)

class NameValidator:
    """Validates and sanitizes names for security and convention compliance"""
    
    # Security patterns
    VALID_IDENTIFIER = re.compile(r'^[a-zA-Z][a-zA-Z0-9_]*$')
    VALID_FILENAME = re.compile(r'^[a-zA-Z][a-zA-Z0-9_-]*$')
    SQL_INJECTION_PATTERNS = [
        r'[;\'\"\\]',  # SQL injection characters
        r'\b(DROP|DELETE|INSERT|UPDATE|CREATE|ALTER)\b',  # SQL keywords
        r'--|/\*|\*/',  # SQL comments
    ]
    
    @classmethod
    def validate_table_name(cls, name: str) -> str:
        """Validate and normalize table name"""
        if not name or not name.strip():
            raise ValueError("Table name cannot be empty")
        
        name = name.strip().upper()
        
        # Security check
        cls._check_sql_injection(name)
        
        # Convention check
        if not cls.VALID_IDENTIFIER.match(name.replace('_', 'a')):  # Allow underscores
            raise ValueError(f"Invalid table name: {name}. Use letters, numbers, and underscores only.")
        
        return name
    
    @classmethod
    def validate_class_name(cls, table_name: str) -> str:
        """Generate and validate class name from table name"""
        # Convert to PascalCase
        class_name = cls._to_pascal_case(table_name) + "Extractor"
        
        # Security check
        cls._check_sql_injection(class_name)
        
        if not cls.VALID_IDENTIFIER.match(class_name):
            raise ValueError(f"Generated class name is invalid: {class_name}")
        
        return class_name
    
    @classmethod
    def validate_file_name(cls, table_name: str) -> str:
        """Generate and validate file name from table name"""
        file_name = table_name.lower() + ".py"
        
        # Security check
        cls._check_sql_injection(file_name)
        
        # Path traversal protection
        if '..' in file_name or '/' in file_name or '\\' in file_name:
            raise ValueError(f"Invalid file name: {file_name}. Path traversal detected.")
        
        return file_name
    
    @classmethod
    def validate_csv_names(cls, csv_names: List[str]) -> List[str]:
        """Validate CSV file names"""
        validated = []
        for name in csv_names:
            name = name.strip()
            if not name:
                continue
                
            # Remove .csv extension if present
            if name.endswith('.csv'):
                name = name[:-4]
            
            # Security check
            cls._check_sql_injection(name)
            
            if not cls.VALID_IDENTIFIER.match(name):
                raise ValueError(f"Invalid CSV name: {name}. Use letters, numbers, and underscores only.")
            
            validated.append(name)
        
        return validated
    
    @classmethod
    def validate_dependencies(cls, dependencies: List[str]) -> List[str]:
        """Validate dependency table names"""
        validated = []
        for dep in dependencies:
            validated_dep = cls.validate_table_name(dep)
            validated.append(validated_dep)
        return validated
    
    @classmethod
    def _check_sql_injection(cls, value: str) -> None:
        """Check for SQL injection patterns"""
        for pattern in cls.SQL_INJECTION_PATTERNS:
            if re.search(pattern, value, re.IGNORECASE):
                raise ValueError(f"Security violation: Potentially dangerous pattern detected in '{value}'")
    
    @classmethod
    def _to_pascal_case(cls, snake_str: str) -> str:
        """Convert snake_case to PascalCase"""
        components = snake_str.split('_')
        return ''.join(word.capitalize() for word in components)

class ExtractorBuilder:
    """
    Builder for constructing ExtractorDefinition objects.
    Implements Builder Pattern with validation and defaults.
    """
    
    def __init__(self):
        self.reset()
    
    def reset(self) -> 'ExtractorBuilder':
        """Reset builder to initial state"""
        self._table_name: Optional[str] = None
        self._csv_inputs: List[str] = []
        self._dependencies: List[str] = []
        return self
    
    def table_name(self, name: str) -> 'ExtractorBuilder':
        """Set table name with validation"""
        self._table_name = NameValidator.validate_table_name(name)
        return self
    
    def csv_inputs(self, csv_names: List[str]) -> 'ExtractorBuilder':
        """Set CSV input names with validation"""
        self._csv_inputs = NameValidator.validate_csv_names(csv_names)
        return self
    
    def dependencies(self, deps: List[str]) -> 'ExtractorBuilder':
        """Set dependency table names with validation"""
        self._dependencies = NameValidator.validate_dependencies(deps)
        return self
    
    def build(self) -> ExtractorDefinition:
        """Build and validate the complete ExtractorDefinition"""
        if not self._table_name:
            raise ValueError("Table name is required")
        
        class_name = NameValidator.validate_class_name(self._table_name)
        file_name = NameValidator.validate_file_name(self._table_name)
        
        definition = ExtractorDefinition(
            table_name=self._table_name,
            class_name=class_name,
            file_name=file_name,
            csv_inputs=self._csv_inputs.copy(),
            dependencies=self._dependencies.copy()
        )
        
        # Validate for circular dependencies
        if self._table_name in self._dependencies:
            raise ValueError(f"Circular dependency detected: {self._table_name} cannot depend on itself")
        
        return definition

class ExtractorGenerator:
    """
    Main generator that coordinates the extraction process.
    Implements Facade Pattern for complex generation operations.
    """
    
    def __init__(self, extractors_folder: str = "extractors"):
        self.extractors_folder = Path(extractors_folder)
        self.template = ExtractorTemplate()
        
        # Ensure extractors folder exists
        self.extractors_folder.mkdir(exist_ok=True)
    
    def generate(self, definition: ExtractorDefinition, 
                overwrite: bool = False, 
                dry_run: bool = False) -> bool:
        """
        Generate extractor file with atomic operations and safety checks.
        
        Args:
            definition: Extractor specification
            overwrite: Whether to overwrite existing files
            dry_run: If True, show what would be generated without creating files
            
        Returns:
            True if generation successful, False otherwise
        """
        target_path = self.extractors_folder / definition.file_name
        
        # Check for existing file
        if target_path.exists() and not overwrite:
            logger.error(f"File already exists: {target_path}")
            logger.info("Use --overwrite to replace existing file")
            return False
        
        # Generate content
        content = self._generate_content(definition)
        
        if dry_run:
            self._preview_generation(definition, content)
            return True
        
        # Atomic file generation
        return self._write_file_atomic(target_path, content, backup=overwrite)
    
    def _generate_content(self, definition: ExtractorDefinition) -> str:
        """Generate the complete file content"""
        template = self.template.get_base_template()
        
        # Template substitution
        content = template.format(
            file_name=definition.file_name,
            class_name=definition.class_name,
            table_name=definition.table_name,
            timestamp=datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            csv_inputs=', '.join(definition.csv_inputs) or 'None',
            dependencies=', '.join(definition.dependencies) or 'None',
            dependencies_list=repr(definition.dependencies),
            extract_parameters=self.template.generate_extract_parameters(
                definition.csv_inputs, definition.dependencies
            ),
            parameter_docs=self.template.generate_parameter_docs(
                definition.csv_inputs, definition.dependencies
            ),
            extraction_example=self.template.generate_extraction_example(
                definition.csv_inputs, definition.dependencies
            )
        )
        
        return content
    
    def _write_file_atomic(self, target_path: Path, content: str, backup: bool = False) -> bool:
        """Write file atomically with optional backup"""
        try:
            # Create backup if requested
            if backup and target_path.exists():
                backup_path = target_path.with_suffix(f'.backup.{int(datetime.now().timestamp())}')
                shutil.copy2(target_path, backup_path)
                logger.info(f"Created backup: {backup_path}")
            
            # Atomic write using temporary file
            with tempfile.NamedTemporaryFile(
                mode='w', 
                dir=target_path.parent,
                prefix=f'.{target_path.name}.',
                suffix='.tmp',
                delete=False,
                encoding='utf-8'
            ) as tmp_file:
                tmp_file.write(content)
                tmp_path = tmp_file.name
            
            # Atomic move
            shutil.move(tmp_path, target_path)
            
            logger.info(f"âœ“ Generated extractor: {target_path}")
            return True
            
        except Exception as e:
            logger.error(f"Failed to generate {target_path}: {str(e)}")
            # Cleanup temporary file if it exists
            try:
                if 'tmp_path' in locals():
                    os.unlink(tmp_path)
            except:
                pass
            return False
    
    def _preview_generation(self, definition: ExtractorDefinition, content: str) -> None:
        """Show preview of what would be generated"""
        print("\n" + "=" * 60)
        print("PREVIEW: Extractor Generation")
        print("=" * 60)
        print(f"Table Name:     {definition.table_name}")
        print(f"Class Name:     {definition.class_name}")
        print(f"File Name:      {definition.file_name}")
        print(f"CSV Inputs:     {definition.csv_inputs or 'None'}")
        print(f"Dependencies:   {definition.dependencies or 'None'}")
        print(f"Target Path:    {self.extractors_folder / definition.file_name}")
        print("\n" + "-" * 60)
        print("Generated Content Preview (first 20 lines):")
        print("-" * 60)
        lines = content.split('\n')
        for i, line in enumerate(lines[:20]):
            print(f"{i+1:2d}: {line}")
        if len(lines) > 20:
            print(f"... ({len(lines) - 20} more lines)")
        print("=" * 60)

class ExtractorGeneratorCLI:
    """
    Command-line interface for the extractor generator.
    Implements Command Pattern with comprehensive validation.
    """
    
    def __init__(self):
        self.generator = ExtractorGenerator()
        self.builder = ExtractorBuilder()
    
    def run(self) -> int:
        """Main entry point that returns exit code"""
        try:
            args = self._parse_arguments()
            
            # Build extractor definition
            definition = self._build_definition(args)
            
            # Generate extractor
            success = self.generator.generate(
                definition=definition,
                overwrite=args.overwrite,
                dry_run=args.dry_run
            )
            
            if success:
                if args.dry_run:
                    print("\nâœ“ Dry run completed - no files were created")
                else:
                    print(f"\nðŸŽ‰ Successfully generated {definition.class_name}!")
                    print(f"ðŸ“ File: {self.generator.extractors_folder / definition.file_name}")
                    print(f"\nðŸ’¡ Next steps:")
                    print(f"   1. Edit the extract() method in {definition.file_name}")
                    print(f"   2. Implement your data transformation logic")
                    print(f"   3. Test with: python3 simple_db_populator.py")
                return 0
            else:
                print("\nâŒ Generation failed!")
                return 1
                
        except Exception as e:
            logger.error(f"CLI error: {str(e)}")
            print(f"\nðŸ’¥ Error: {str(e)}")
            return 1
    
    def _parse_arguments(self) -> argparse.Namespace:
        """Parse and validate command line arguments"""
        parser = argparse.ArgumentParser(
            description="Generate extractor files for database population tool",
            formatter_class=argparse.RawDescriptionHelpFormatter,
            epilog="""
Examples:
  # Basic table
  python3 extractor_generator.py STUDENT
  
  # With CSV inputs
  python3 extractor_generator.py COURSE --csv offeredCourses,courseData
  
  # With dependencies
  python3 extractor_generator.py ENROLLMENT --deps STUDENT,COURSE
  
  # Preview without creating
  python3 extractor_generator.py TEACHER --dry-run
  
  # Overwrite existing
  python3 extractor_generator.py PROFESSOR --overwrite
            """
        )
        
        parser.add_argument('table_name', 
                          help='Name of the database table (will be normalized to uppercase)')
        
        parser.add_argument('--csv', '--csv-inputs',
                          dest='csv_inputs',
                          help='Comma-separated list of CSV file names (without .csv extension)')
        
        parser.add_argument('--deps', '--dependencies',
                          dest='dependencies', 
                          help='Comma-separated list of dependency table names')
        
        parser.add_argument('--extractors-folder',
                          default='extractors',
                          help='Path to extractors folder (default: extractors)')
        
        parser.add_argument('--overwrite',
                          action='store_true',
                          help='Overwrite existing extractor file')
        
        parser.add_argument('--dry-run',
                          action='store_true',
                          help='Show what would be generated without creating files')
        
        return parser.parse_args()
    
    def _build_definition(self, args: argparse.Namespace) -> ExtractorDefinition:
        """Build ExtractorDefinition from CLI arguments"""
        self.builder.reset()
        
        # Set table name
        self.builder.table_name(args.table_name)
        
        # Set CSV inputs
        if args.csv_inputs:
            csv_list = [name.strip() for name in args.csv_inputs.split(',')]
            self.builder.csv_inputs(csv_list)
        
        # Set dependencies
        if args.dependencies:
            deps_list = [name.strip() for name in args.dependencies.split(',')]
            self.builder.dependencies(deps_list)
        
        # Update generator folder
        self.generator.extractors_folder = Path(args.extractors_folder)
        self.generator.extractors_folder.mkdir(exist_ok=True)
        
        return self.builder.build()

def main():
    """Main entry point"""
    cli = ExtractorGeneratorCLI()
    sys.exit(cli.run())

if __name__ == "__main__":
    main()